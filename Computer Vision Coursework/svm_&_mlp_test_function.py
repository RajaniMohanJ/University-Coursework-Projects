# -*- coding: utf-8 -*-
"""SVM & MLP test_function.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W6bFybzvR1VbOr8UptP7D-Holg5a13wT

# Computer Vision Coursework Submission (IN3060/INM460)

**Student name, ID and cohort:** Rajani Mohan Janipalli (210049506) - PG

# Notebook Setup
In this section you should include all the code cells required to test your coursework submission. Specifically:

### Mount Google Drive
"""

from google.colab import drive
drive.mount('/content/drive')

"""### Define Local Path

In the next cell you should assign to the variable `GOOGLE_DRIVE_PATH_AFTER_MYDRIVE` the relative path of this folder in your Google Drive.

**IMPORTANT:** you have to make sure that **all the files required to test your functions are loaded using this variable** (as was the case for all lab tutorials). In other words, do not use in the notebook any absolute paths. This will ensure that the markers can run your functions. Also, **do not use** the magic command `%cd` to change directory.


"""

import os

# TODO: Fill in the Google Drive path where you uploaded the CW_folder_PG
# Example: GOOGLE_DRIVE_PATH_AFTER_MYDRIVE = 'Colab Notebooks/Computer Vision/CW_folder_PG'

GOOGLE_DRIVE_PATH_AFTER_MYDRIVE = 'Colab Notebooks/Computer Vision Coursework/CW_Folder_PG'
GOOGLE_DRIVE_PATH = os.path.join('drive', 'My Drive', GOOGLE_DRIVE_PATH_AFTER_MYDRIVE)
print(os.listdir(GOOGLE_DRIVE_PATH))

"""### Load packages 

In the next cell you should load all the packages required to test your functions.

**NOTE:** Please run the below code cell twice to avoid error message.
"""

!pip install opencv-python==4.5.5.64

# Commented out IPython magic to ensure Python compatibility.
!pip show opencv-python

import cv2
from sklearn.model_selection import train_test_split
from skimage import img_as_ubyte, io, color
from sklearn.cluster import MiniBatchKMeans
from sklearn import svm, metrics
import matplotlib.pyplot as plt
import numpy as np
from collections import Counter

# %matplotlib inline

import pickle
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import GridSearchCV
import time
from sklearn.neural_network import MLPClassifier
from skimage.feature import hog
from skimage import data, exposure
import random

# Identify path to zipped dataset
CW_zip_path = os.path.join(GOOGLE_DRIVE_PATH, 'CW_Dataset', 'CW_Dataset.zip')

# Copy it to Colab
!cp '{CW_zip_path}' .

# Unzip it
!yes|unzip -q CW_Dataset.zip

# Delete zipped version from Colab (not from Drive)
!rm CW_Dataset.zip

"""### Load models

In the next cell you should load all your trained models for easier testing of your functions. Avoid to load them within `EmotionRecognition` and `EmotionRecognitionVideo` to avoid having to reload them each time.
"""

bestsiftsvmpath = os.path.join(GOOGLE_DRIVE_PATH, 'Models/best_siftSVM_model.pickle')

with open (bestsiftsvmpath, 'rb') as f:
    best_siftSVM_model_loaded = pickle.load(f)

###############################################################################################################################################################################

bestsiftmlppath = os.path.join(GOOGLE_DRIVE_PATH, 'Models/best_siftMLP_model.pickle')

with open (bestsiftmlppath, 'rb') as f:
    best_siftMLP_model_loaded = pickle.load(f)

###############################################################################################################################################################################

besthogsvmpath = os.path.join(GOOGLE_DRIVE_PATH, 'Models/best_hogSVM_model.pickle')

with open (besthogsvmpath, 'rb') as f:
    best_hogSVM_model_loaded = pickle.load(f)

###############################################################################################################################################################################

besthogmlppath = os.path.join(GOOGLE_DRIVE_PATH, 'Models/best_hogMLP_model.pickle')

with open (besthogmlppath, 'rb') as f:
    best_hogMLP_model_loaded = pickle.load(f)

###############################################################################################################################################################################

siftkmeanspath = os.path.join(GOOGLE_DRIVE_PATH, 'Models/siftKMeans.pickle')

with open (siftkmeanspath, 'rb') as f:
    siftKMeans = pickle.load(f)

"""# Test EmotionRecognition

This section should allow a quick test of the `EmotionRecognition` function. First, add cells with the code needed to load the necessary subroutines to make `EmotionRecognition` work.

*NOTE: All the code below has been complied from different scripts containing SVM & MLP models and CNN models. To keep this script tidy, no references were given here, but all the references can be found in the respective model scripts.*
"""

path_to_testset = os.path.join(GOOGLE_DRIVE_PATH, 'CW_Dataset')

def EmotionRecognition(path_to_testset, model_name):

  def import_imagelabels_lists(path):
    """Load images and labels from selected directories"""
    images = []

    file_names = [file for file in sorted(os.listdir(os.path.join(path))) if file.endswith('.jpg')]
    for file in file_names:
        images.append(io.imread(os.path.join(path, file)))
    
    label_set = np.loadtxt(os.path.join('labels', 'list_label_{}.txt'.format(path)), dtype='str')
    label_nums = [] # create an empty list to append label numbers.
    for i in range(len(label_set)): # execute a for loop to extract the exact labels from data and append them to a list.
      label_nums.append(label_set[i][1])
    
    label_names = ['Suprise' if p == '1' else 'Fear' if p == '2' else 'Disgust' if p == '3' else 'Happiness' if p == '4' else 'Sadness' if p == '5' else 'Anger' if p == '6' else 'Neutral' for p in label_nums]

    return images,label_names
  
  X_test, y_test = import_imagelabels_lists('test')

  
  if model_name == 'SIFT-SVM' or model_name == 'SIFT-MLP':
      
    sift = cv2.SIFT_create()
    k = len(np.unique(y_test)) * 10
    testhist_list = []

    for i in range(len(X_test)):
        testimg = img_as_ubyte(color.rgb2gray(X_test[i]))
        testkp, testdes = sift.detectAndCompute(testimg, None)

        if testdes is not None:
            testhist = np.zeros(k)

            testidx = siftKMeans.predict(testdes)

            for j in testidx:
                testhist[j] = testhist[j] + (1 / len(testdes))

            # hist = scale.transform(hist.reshape(1, -1))
            testhist_list.append(testhist)

        else:
            testhist_list.append(None)

    # Remove potential cases of images with no descriptors
    testidx_not_empty = [i for i, x in enumerate(testhist_list) if x is not None]
    testhist_list = [testhist_list[i] for i in testidx_not_empty]
    y_test1 = [y_test[i] for i in testidx_not_empty]
    testhist_array = np.vstack(testhist_list)

  if model_name == 'HOG-SVM' or model_name == 'HOG-MLP':
      
    testhog_images = []
    testhog_descriptors = []

    X_test_gray = [ color.rgb2gray(i) for i in X_test]

    for i in range(len(X_test)):
        # Identify keypoints and extract descriptors with SIFT
        testimg_hog = img_as_ubyte(np.array(X_test_gray[i]))
        testfet_des, testhog_img = hog(testimg_hog, orientations=8, pixels_per_cell=(16, 16), cells_per_block=(4, 4), visualize=True, multichannel=False)
        testhog_descriptors.append(testfet_des)
        testhog_images.append(testhog_img)


    fig, ax = plt.subplots(1, 2, figsize=(10, 8), sharex=True, sharey=True)

    ax[0].axis('off')
    ax[0].imshow(X_test_gray[0])
    ax[0].set_title('Original image')

    # Rescale histogram for better display
    testhog_img_rescale = exposure.rescale_intensity(testhog_images[0], in_range=(0, 10))

    ax[1].axis('off')
    ax[1].imshow(testhog_img_rescale, cmap='gray')
    ax[1].set_title('Histogram of Oriented Gradients')
    fig.tight_layout()
    plt.show()
  
  if model_name == 'SIFT-SVM':

    y_pred = best_siftSVM_model_loaded.predict(testhist_array).tolist()

    fig, axes = plt.subplots(2, 5, figsize=(14, 7), sharex=True, sharey=True)
    ax = axes.ravel()

    random.shuffle(X_test)
    for i in range(10):
        ax[i].imshow(X_test[i])
        ax[i].set_title(f'Label: {y_test1[i]} \n Prediction: {y_pred[i]}')
        ax[i].set_axis_off()
    fig.tight_layout()
    plt.show()

    siftSVM_test_score = best_siftSVM_model_loaded.score(testhist_array, y_test1)
    print("Test score of SIFT-SVM model is {}.".format(siftSVM_test_score))
    
    print(f"""Classification report for classifier best siftSVM- {best_siftSVM_model_loaded}:
      {metrics.classification_report(y_test1, y_pred)}\n""")
    
    metrics.ConfusionMatrixDisplay.from_predictions(y_test1, y_pred)
    plt.show()
  
  elif model_name == 'SIFT-MLP':
    y_pred_siftMLP = best_siftMLP_model_loaded.predict(testhist_array).tolist()

    fig, axes = plt.subplots(2, 5, figsize=(14, 7), sharex=True, sharey=True)
    ax = axes.ravel()

    random.shuffle(X_test)
    for i in range(10):
        ax[i].imshow(X_test[i])
        ax[i].set_title(f'Label: {y_test1[i]} \n Prediction: {y_pred_siftMLP[i]}')
        ax[i].set_axis_off()
    fig.tight_layout()
    plt.show()


    siftMLP_test_score = best_siftMLP_model_loaded.score(testhist_array, y_test1)
    print("Test score of SIFT-MLP model is {}.".format(siftMLP_test_score))
    
    print(f"""Classification report for classifier best siftMPL- {best_siftMLP_model_loaded}:
      {metrics.classification_report(y_test1, y_pred_siftMLP)}\n""")
    
    metrics.ConfusionMatrixDisplay.from_predictions(y_test1, y_pred_siftMLP)
    plt.show()
  
  elif model_name == 'HOG-SVM':

    y_pred_hogSVM = best_hogSVM_model_loaded.predict(testhog_descriptors)

    fig, axes = plt.subplots(2, 5, figsize=(14, 7), sharex=True, sharey=True)
    ax = axes.ravel()

    random.shuffle(X_test)
    for i in range(10):
        ax[i].imshow(X_test[i])
        ax[i].set_title(f'Label: {y_test[i]} \n Prediction: {y_pred_hogSVM[i]}')
        ax[i].set_axis_off()
    fig.tight_layout()
    plt.show()


    hogSVM_test_score = best_hogSVM_model_loaded.score(testhog_descriptors, y_test)
    print("Test score of HOG-SVM model is {}.".format(hogSVM_test_score))
    
    print(f"""Classification report for classifier best hogSVM- {best_hogSVM_model_loaded}:
      {metrics.classification_report(y_test, y_pred_hogSVM)}\n""")
    
    metrics.ConfusionMatrixDisplay.from_predictions(y_test, y_pred_hogSVM)
    plt.show()
  
  elif model_name == 'HOG-MLP':
    y_pred_hogMLP = best_hogMLP_model_loaded.predict(testhog_descriptors)

    fig, axes = plt.subplots(2, 5, figsize=(14, 7), sharex=True, sharey=True)
    ax = axes.ravel()

    random.shuffle(X_test)
    for i in range(10):
        ax[i].imshow(X_test[i])
        ax[i].set_title(f'Label: {y_test[i]} \n Prediction: {y_pred_hogMLP[i]}')
        ax[i].set_axis_off()
    fig.tight_layout()
    plt.show()


    hogMLP_test_score = best_hogMLP_model_loaded.score(testhog_descriptors, y_test)
    print("Test score of HOG-MLP model is {}.".format(hogMLP_test_score))
    
    print(f"""Classification report for classifier best hogMLP- {best_hogMLP_model_loaded}:
      {metrics.classification_report(y_test, y_pred_hogMLP)}\n""")
    
    metrics.ConfusionMatrixDisplay.from_predictions(y_test, y_pred_hogMLP)
    plt.show()

"""Then, make a call to the `EmotionRecognition` function to see what results it produces. You must also indicate the syntax needed to test your different models."""

EmotionRecognition(path_to_testset, 'SIFT-SVM')

EmotionRecognition(path_to_testset, 'SIFT-MLP')

EmotionRecognition(path_to_testset, 'HOG-SVM')

EmotionRecognition(path_to_testset, 'HOG-MLP')

"""# Test EmotionRecognitionVideo

This section should allow a quick test of the `EmotionRecognitionVideo` function. First, add cells with the code needed to load the necessary subroutines to make `EmotionRecognitionVideo` work.

Then, make a call to the `EmotionRecognitionVideo` function to see what results it produces.

## *Since none of the above models were the best, the EmotionRecognitionVideo function was not tested in this script.*
"""